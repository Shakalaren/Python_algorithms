"""
Задание 2.
Реализуйте два алгоритма.
Оба должны обеспечивать поиск минимального значения для списка.
Сложность первого алгоритма должна быть O(n^2) - квадратичная.
Сложность второго алгоритма должна быть O(n) - линейная.
Примечание: ПРОШУ ВАС ВНИМАТЕЛЬНО ЧИТАТЬ ЗАДАНИЕ!
-- нельзя использовать встроенные функции min() и sort()
"""


from memory_profiler import profile
"""
Данная рекурсия взята из Task_2.3, на основе которой также выполнялся Task_6.1 
Из Task_2.3 
Задание 3.	Сформировать из введенного числа
обратное по порядку входящих в него
цифр и вывести на экран. Например, если введено число 3486,
то надо вывести число 6843.
"""

count = int(input('Введите число, которое хотите перевернуть: '))
original_count = count

def count_recur(count, new_number=[]):
    if count == 0:
        print(f'Ваше изначальное число: {original_count}, перевернутое: {"".join((map(str, new_number)))}')
    else:
        reversed_number = count % 10
        count = count // 10
        new_number.append(reversed_number)
        return count_recur(count, new_number)

# Проблема была замечена ранее. Рекурсия при замере времени выдает огромное количество таблиц.
# Если декорировать не саму функцию, а ее "обертку" fix_count(count_recur), то замеры пойдут в нормальном виде, так как
# мы замеряем не каждый шаг рекурсии, а всю функцию count_recur целиком. 

@profile
def fix_count(count_recur):
    return count_recur(count, new_number=[])

fix_count(count_recur)